rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      // Allow all authenticated users to read any user profile (for friend search)
      allow read: if isAuthenticated();

      // Users can create their own profile
      allow create: if isOwner(userId);

      // Users can update their own profile OR their friends field can be updated by others
      // when accepting friend requests (mutual friend addition)
      allow update: if isOwner(userId) ||
        // Allow updating only the friends field when there's an accepted friend request
        (isAuthenticated() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends']) &&
         request.resource.data.friends.keys().hasAny([request.auth.uid]));

      // Prevent deletion for now
      allow delete: if false;
    }

    // Expenses collection
    match /expenses/{expenseId} {
      // Allow read if user is the payer or is in splitWith list
      allow get: if isAuthenticated() && (
        resource.data.paidBy == request.auth.uid ||
        request.auth.uid in resource.data.splitWith
      );

      // Allow list/query operations for authenticated users
      // (individual document rules will still be checked during reads)
      allow list: if isAuthenticated();

      // Allow create if user is authenticated and is the payer
      allow create: if isAuthenticated() &&
        request.resource.data.paidBy == request.auth.uid;

      // Allow update/delete only if user is the payer
      allow update, delete: if isAuthenticated() &&
        resource.data.paidBy == request.auth.uid;
    }

    // Groups collection
    match /groups/{groupId} {
      // Allow read if user is a member
      allow read: if isAuthenticated() &&
        request.auth.uid in resource.data.members;

      // Allow create if user is authenticated and is in members list
      allow create: if isAuthenticated() &&
        request.auth.uid in request.resource.data.members;

      // Allow update if user is a member
      allow update: if isAuthenticated() &&
        request.auth.uid in resource.data.members;

      // Allow delete only if user is the creator
      allow delete: if isAuthenticated() &&
        resource.data.createdBy == request.auth.uid;
    }

    // Friend Requests collection
    match /friendRequests/{requestId} {
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Allow create if user is authenticated and is the sender
      allow create: if isAuthenticated() &&
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Allow update if user is the receiver (to accept/reject) or sender (to cancel)
      allow update: if isAuthenticated() && (
        // Receiver can accept or reject
        (resource.data.toUserId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'rejected']) ||
        // Sender can only update if accepting (mutual acceptance logic)
        (resource.data.fromUserId == request.auth.uid &&
         resource.data.status == 'pending')
      );

      // Allow delete if user is the sender and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.fromUserId == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Group Invitations collection
    match /groupInvitations/{invitationId} {
      // Allow read if user is invited or is a member of the group
      allow read: if isAuthenticated() && (
        resource.data.invitedUserId == request.auth.uid ||
        resource.data.invitedBy == request.auth.uid ||
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.members
      );

      // Allow create if user is authenticated and is a member of the group
      allow create: if isAuthenticated() &&
        request.resource.data.invitedBy == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.members;

      // Allow update if user is the invited person (to accept/reject)
      allow update: if isAuthenticated() &&
        resource.data.invitedUserId == request.auth.uid &&
        resource.data.status == 'pending' &&
        request.resource.data.status in ['accepted', 'rejected'];

      // Allow delete if user is the inviter and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.invitedBy == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Activity/transactions collection (if you add one later)
    match /activities/{activityId} {
      // Allow read if user is involved
      allow read: if isAuthenticated();

      // System creates activities, users don't
      allow write: if false;
    }
  }
}
