rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if user is an admin
    // Add your admin email(s) here
    function isAdmin() {
      return isAuthenticated() && request.auth.token.email in [
        'blrtechpub@gmail.com'
      ];
    }

    // Users collection
    match /users/{userId} {
      // Allow all authenticated users to read any user profile (for friend search)
      allow read: if isAuthenticated();

      // Users can create their own profile
      allow create: if isOwner(userId);

      // Users can update their own profile OR their friends field can be updated by others
      // when accepting friend requests (mutual friend addition)
      allow update: if isOwner(userId) ||
        // Allow updating only the friends field when there's an accepted friend request
        (isAuthenticated() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends']) &&
         request.resource.data.friends.keys().hasAny([request.auth.uid]));

      // Prevent deletion for now
      allow delete: if false;

      // Investment Assets subcollection
      match /investmentAssets/{assetId} {
        // Users can only access their own investment assets
        allow read, write: if isOwner(userId);
      }

      // Investment Holdings subcollection
      match /investmentHoldings/{holdingId} {
        // Users can only access their own holdings
        allow read, write: if isOwner(userId);
      }

      // Investment Transactions subcollection
      match /investmentTransactions/{txnId} {
        // Users can only access their own transactions
        allow read, write: if isOwner(userId);
      }

      // Portfolio Valuations subcollection
      match /portfolioValuations/{valuationId} {
        // Users can only access their own portfolio valuations
        allow read, write: if isOwner(userId);
      }

      // Investment SMS Queue subcollection
      match /investmentSmsQueue/{queueId} {
        // Users can only access their own investment SMS queue
        allow read, write: if isOwner(userId);
      }

      // Email Transaction Queue subcollection
      match /emailTransactionQueue/{queueId} {
        // Users can only access their own email transactions
        allow read, write: if isOwner(userId);
      }

      // Custom Email Patterns subcollection (Smart Email Parsing)
      match /customEmailPatterns/{patternId} {
        // Users can read/write their own patterns, admins can read all
        allow read: if isOwner(userId) || isAdmin();
        allow write: if isOwner(userId);
      }

      // Email Learning Data subcollection (Manual corrections)
      match /emailLearningData/{learningId} {
        // Users can only access their own learning data
        allow read, write: if isOwner(userId);
      }

      // Credit Card Statement Queue subcollection
      match /creditCardStatementQueue/{queueId} {
        // Users can only access their own credit card statements
        allow read, write: if isOwner(userId);
      }

      // Account Trackers subcollection (Email sync configuration)
      match /accountTrackers/{trackerId} {
        // Users can only access their own account trackers
        allow read, write: if isOwner(userId);
      }
    }

    // Expenses collection
    match /expenses/{expenseId} {
      // Allow read if user is the payer or is in splitWith list, or is admin
      allow get: if isAuthenticated() && (
        resource.data.paidBy == request.auth.uid ||
        request.auth.uid in resource.data.splitWith ||
        isAdmin()
      );

      // Allow list/query operations for authenticated users and admins
      // (individual document rules will still be checked during reads)
      allow list: if isAuthenticated() || isAdmin();

      // Allow create if user is authenticated and involved in the expense (Splitwise-style)
      // User can create expense if they are:
      // 1. The payer (for personal expenses), OR
      // 2. In the splitWith list (for friend expenses), OR
      // 3. A member of the group (for group expenses - can add on behalf of others)
      allow create: if isAuthenticated() && (
        request.resource.data.paidBy == request.auth.uid ||
        request.auth.uid in request.resource.data.splitWith ||
        (request.resource.data.groupId != null && request.resource.data.groupId != '' &&
         request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.members) ||
        isAdmin()
      );

      // Allow update/delete if user is involved in the expense (Splitwise-style)
      // User can modify if they are:
      // 1. The payer, OR
      // 2. In the splitWith list (for friend expenses), OR
      // 3. A member of the group (for group expenses)
      allow update, delete: if isAuthenticated() && (
        resource.data.paidBy == request.auth.uid ||
        request.auth.uid in resource.data.splitWith ||
        (resource.data.groupId != null && resource.data.groupId != '' &&
         request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.members) ||
        isAdmin()
      );
    }

    // Groups collection
    match /groups/{groupId} {
      // Allow all authenticated users to read group info
      // (needed for users to see group details when they receive invitations)
      allow read: if isAuthenticated();

      // Allow create if user is authenticated and is in members list
      allow create: if isAuthenticated() &&
        request.auth.uid in request.resource.data.members;

      // Allow update if:
      // 1. User is already a member (can update any field), OR
      // 2. User is only adding themselves to members (accepting invitation)
      allow update: if isAuthenticated() && (
        // Existing member can update
        request.auth.uid in resource.data.members ||
        // Non-member can only add themselves to members array (nothing else)
        (request.auth.uid in request.resource.data.members &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members']) &&
         request.resource.data.members.hasAll(resource.data.members))
      );

      // Allow delete only if user is the creator
      allow delete: if isAuthenticated() &&
        resource.data.createdBy == request.auth.uid;
    }

    // Friend Requests collection
    match /friendRequests/{requestId} {
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Allow create if user is authenticated and is the sender
      allow create: if isAuthenticated() &&
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Allow update if user is the receiver (to accept/reject) or sender (to cancel)
      allow update: if isAuthenticated() && (
        // Receiver can accept or reject
        (resource.data.toUserId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'rejected']) ||
        // Sender can only update if accepting (mutual acceptance logic)
        (resource.data.fromUserId == request.auth.uid &&
         resource.data.status == 'pending')
      );

      // Allow delete if user is the sender and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.fromUserId == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Group Invitations collection
    match /groupInvitations/{invitationId} {
      // Allow read if user is invited or is a member of the group
      allow read: if isAuthenticated() && (
        resource.data.invitedUserId == request.auth.uid ||
        resource.data.invitedBy == request.auth.uid ||
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.members
      );

      // Allow create if user is authenticated and is a member of the group
      allow create: if isAuthenticated() &&
        request.resource.data.invitedBy == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.members;

      // Allow update if user is the invited person (to accept/reject)
      allow update: if isAuthenticated() &&
        resource.data.invitedUserId == request.auth.uid &&
        resource.data.status == 'pending' &&
        request.resource.data.status in ['accepted', 'rejected'];

      // Allow delete if user is the inviter and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.invitedBy == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Activity/transactions collection (if you add one later)
    match /activities/{activityId} {
      // Allow read if user is involved
      allow read: if isAuthenticated();

      // System creates activities, users don't
      allow write: if false;
    }

    // Bug Reports collection
    match /bugReports/{reportId} {
      // Users can read their own bug reports, admins can read all
      allow read: if isAuthenticated() && (
        resource.data.reportedBy == request.auth.uid ||
        isAdmin()
      );

      // Any authenticated user can create a bug report
      allow create: if isAuthenticated() &&
        request.resource.data.reportedBy == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Only admins can update bug reports (change status, add GitHub URL)
      allow update: if isAdmin();

      // Users cannot delete bug reports
      allow delete: if false;
    }

    // Money Accounts collection (Bank accounts and Credit cards)
    match /moneyAccounts/{accountId} {
      // Users can read their own money accounts
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create money accounts for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own money accounts
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own money accounts
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Salary Records collection
    match /salaryRecords/{salaryId} {
      // Users can read their own salary records
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create salary records for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own salary records
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own salary records
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Email Transactions collection
    match /email_transactions/{transactionId} {
      // Users can read their own email transactions
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create email transactions for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own email transactions
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own email transactions
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // SMS Expenses collection
    match /sms_expenses/{smsExpenseId} {
      // Users can read their own SMS expenses
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create SMS expenses for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Users can update their own SMS expenses (categorize, ignore)
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own SMS expenses
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Settlements/Payments collection
    match /settlements/{settlementId} {
      // Users can read settlements where they are sender or receiver
      allow read: if isAuthenticated() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Users can create settlements where they are the sender
      allow create: if isAuthenticated() &&
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.isVerified == false;

      // Only receiver can verify the settlement
      allow update: if isAuthenticated() &&
        resource.data.toUserId == request.auth.uid &&
        resource.data.isVerified == false &&
        request.resource.data.isVerified == true &&
        // Only verification fields can be updated
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isVerified', 'verifiedAt']);

      // Sender can delete unverified settlements they created
      allow delete: if isAuthenticated() &&
        resource.data.fromUserId == request.auth.uid &&
        resource.data.isVerified == false;
    }

    // Receipts collection
    match /receipts/{receiptId} {
      // Users can read their own receipts
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create receipts for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own receipts
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own receipts
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Receipt Items collection
    match /receipt_items/{itemId} {
      // Users can read their own receipt items
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create receipt items for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own receipt items
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own receipt items
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Bill Upload History collection
    match /bill_upload_history/{historyId} {
      // Users can read their own upload history
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create upload history for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // No updates or deletes (append-only log)
      allow update, delete: if false;
    }

    // Regex Patterns collections (for self-learning AI system)
    match /regex_patterns/sms_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // Allow authenticated app to create/update patterns from AI learning
      allow write: if isAuthenticated();
    }

    match /regex_patterns/bill_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // Allow authenticated app to create/update patterns from AI learning
      allow write: if isAuthenticated();
    }

    match /regex_patterns/receipt_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // Allow authenticated app to create/update patterns from AI learning
      allow write: if isAuthenticated();
    }

    // Global Email Parsing Patterns (Smart Email Parsing)
    match /emailParsingPatterns/{patternId} {
      // All authenticated users can read global patterns
      allow read: if isAuthenticated();

      // Only Cloud Functions can create/update patterns (via admin SDK)
      // Users cannot directly write to global patterns
      allow write: if false;
    }

    // Account Trackers collection (Top-level for querying across users)
    match /accountTrackers/{trackerId} {
      // Users can read/write their own trackers
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create trackers for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own trackers
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own trackers
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Budgets collection (Monthly budget tracking)
    match /budgets/{budgetId} {
      // Users can only access their own budgets
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create budgets for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own budgets
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own budgets
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Savings Goals collection
    match /savingsGoals/{goalId} {
      // Users can only access their own savings goals
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create savings goals for themselves
      // Validates required fields and initial values
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'title', 'targetAmount', 'currentAmount', 'deadline', 'createdAt', 'isCompleted']) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.targetAmount is number &&
        request.resource.data.targetAmount > 0 &&
        request.resource.data.currentAmount is number &&
        request.resource.data.currentAmount >= 0 &&
        request.resource.data.deadline is timestamp &&
        request.resource.data.createdAt is timestamp &&
        request.resource.data.isCompleted is bool;

      // Users can update their own savings goals
      // Validates data types and constraints
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid &&
        // Target amount should not change after creation
        request.resource.data.targetAmount == resource.data.targetAmount &&
        // Current amount must be >= 0 and <= target amount
        request.resource.data.currentAmount >= 0 &&
        request.resource.data.currentAmount <= request.resource.data.targetAmount &&
        // If completed, current amount should equal target amount
        (!request.resource.data.isCompleted || request.resource.data.currentAmount == request.resource.data.targetAmount);

      // Users can delete their own savings goals
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }
  }
}
