rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      // Allow all authenticated users to read any user profile (for friend search)
      allow read: if isAuthenticated();

      // Users can create their own profile
      allow create: if isOwner(userId);

      // Users can update their own profile OR their friends field can be updated by others
      // when accepting friend requests (mutual friend addition)
      allow update: if isOwner(userId) ||
        // Allow updating only the friends field when there's an accepted friend request
        (isAuthenticated() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends']) &&
         request.resource.data.friends.keys().hasAny([request.auth.uid]));

      // Prevent deletion for now
      allow delete: if false;

      // Investment Assets subcollection
      match /investmentAssets/{assetId} {
        // Users can only access their own investment assets
        allow read, write: if isOwner(userId);
      }

      // Investment Holdings subcollection
      match /investmentHoldings/{holdingId} {
        // Users can only access their own holdings
        allow read, write: if isOwner(userId);
      }

      // Investment Transactions subcollection
      match /investmentTransactions/{txnId} {
        // Users can only access their own transactions
        allow read, write: if isOwner(userId);
      }

      // Portfolio Valuations subcollection
      match /portfolioValuations/{valuationId} {
        // Users can only access their own portfolio valuations
        allow read, write: if isOwner(userId);
      }

      // Investment SMS Queue subcollection
      match /investmentSmsQueue/{queueId} {
        // Users can only access their own investment SMS queue
        allow read, write: if isOwner(userId);
      }

      // Email Transaction Queue subcollection
      match /emailTransactionQueue/{queueId} {
        // Users can only access their own email transactions
        allow read, write: if isOwner(userId);
      }

      // Custom Email Patterns subcollection (Smart Email Parsing)
      match /customEmailPatterns/{patternId} {
        // Users can only read, create, update their own custom email patterns
        allow read, write: if isOwner(userId);
      }

      // Email Learning Data subcollection (Manual corrections)
      match /emailLearningData/{learningId} {
        // Users can only access their own learning data
        allow read, write: if isOwner(userId);
      }

      // Credit Card Statement Queue subcollection
      match /creditCardStatementQueue/{queueId} {
        // Users can only access their own credit card statements
        allow read, write: if isOwner(userId);
      }
    }

    // Expenses collection
    match /expenses/{expenseId} {
      // Allow read if user is the payer or is in splitWith list
      allow get: if isAuthenticated() && (
        resource.data.paidBy == request.auth.uid ||
        request.auth.uid in resource.data.splitWith
      );

      // Allow list/query operations for authenticated users
      // (individual document rules will still be checked during reads)
      allow list: if isAuthenticated();

      // Allow create if user is authenticated and is the payer
      allow create: if isAuthenticated() &&
        request.resource.data.paidBy == request.auth.uid;

      // Allow update/delete only if user is the payer
      allow update, delete: if isAuthenticated() &&
        resource.data.paidBy == request.auth.uid;
    }

    // Groups collection
    match /groups/{groupId} {
      // Allow all authenticated users to read group info
      // (needed for users to see group details when they receive invitations)
      allow read: if isAuthenticated();

      // Allow create if user is authenticated and is in members list
      allow create: if isAuthenticated() &&
        request.auth.uid in request.resource.data.members;

      // Allow update if:
      // 1. User is already a member (can update any field), OR
      // 2. User is only adding themselves to members (accepting invitation)
      allow update: if isAuthenticated() && (
        // Existing member can update
        request.auth.uid in resource.data.members ||
        // Non-member can only add themselves to members array (nothing else)
        (request.auth.uid in request.resource.data.members &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members']) &&
         request.resource.data.members.hasAll(resource.data.members))
      );

      // Allow delete only if user is the creator
      allow delete: if isAuthenticated() &&
        resource.data.createdBy == request.auth.uid;
    }

    // Friend Requests collection
    match /friendRequests/{requestId} {
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Allow create if user is authenticated and is the sender
      allow create: if isAuthenticated() &&
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Allow update if user is the receiver (to accept/reject) or sender (to cancel)
      allow update: if isAuthenticated() && (
        // Receiver can accept or reject
        (resource.data.toUserId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'rejected']) ||
        // Sender can only update if accepting (mutual acceptance logic)
        (resource.data.fromUserId == request.auth.uid &&
         resource.data.status == 'pending')
      );

      // Allow delete if user is the sender and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.fromUserId == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Group Invitations collection
    match /groupInvitations/{invitationId} {
      // Allow read if user is invited or is a member of the group
      allow read: if isAuthenticated() && (
        resource.data.invitedUserId == request.auth.uid ||
        resource.data.invitedBy == request.auth.uid ||
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.members
      );

      // Allow create if user is authenticated and is a member of the group
      allow create: if isAuthenticated() &&
        request.resource.data.invitedBy == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.members;

      // Allow update if user is the invited person (to accept/reject)
      allow update: if isAuthenticated() &&
        resource.data.invitedUserId == request.auth.uid &&
        resource.data.status == 'pending' &&
        request.resource.data.status in ['accepted', 'rejected'];

      // Allow delete if user is the inviter and status is pending
      allow delete: if isAuthenticated() &&
        resource.data.invitedBy == request.auth.uid &&
        resource.data.status == 'pending';
    }

    // Activity/transactions collection (if you add one later)
    match /activities/{activityId} {
      // Allow read if user is involved
      allow read: if isAuthenticated();

      // System creates activities, users don't
      allow write: if false;
    }

    // Bug Reports collection
    match /bugReports/{reportId} {
      // Any authenticated user can read their own bug reports
      allow read: if isAuthenticated() &&
        resource.data.reportedBy == request.auth.uid;

      // Any authenticated user can create a bug report
      allow create: if isAuthenticated() &&
        request.resource.data.reportedBy == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Only allow updates to sync status (done by admin/system)
      // Users cannot update their own bug reports
      allow update: if false;

      // Users cannot delete bug reports
      allow delete: if false;
    }

    // SMS Expenses collection
    match /sms_expenses/{smsExpenseId} {
      // Users can read their own SMS expenses
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create SMS expenses for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Users can update their own SMS expenses (categorize, ignore)
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own SMS expenses
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Settlements/Payments collection
    match /settlements/{settlementId} {
      // Users can read settlements where they are sender or receiver
      allow read: if isAuthenticated() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Users can create settlements where they are the sender
      allow create: if isAuthenticated() &&
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.isVerified == false;

      // Only receiver can verify the settlement
      allow update: if isAuthenticated() &&
        resource.data.toUserId == request.auth.uid &&
        resource.data.isVerified == false &&
        request.resource.data.isVerified == true &&
        // Only verification fields can be updated
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isVerified', 'verifiedAt']);

      // Users cannot delete settlements (permanent record)
      allow delete: if false;
    }

    // Receipts collection
    match /receipts/{receiptId} {
      // Users can read their own receipts
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create receipts for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own receipts
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own receipts
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Receipt Items collection
    match /receipt_items/{itemId} {
      // Users can read their own receipt items
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create receipt items for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own receipt items
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own receipt items
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Bill Upload History collection
    match /bill_upload_history/{historyId} {
      // Users can read their own upload history
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Users can create upload history for themselves
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // No updates or deletes (append-only log)
      allow update, delete: if false;
    }

    // Regex Patterns collections (for self-learning AI system)
    match /regex_patterns/sms_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // System creates patterns (users don't directly create)
      allow write: if false;
    }

    match /regex_patterns/bill_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // System creates patterns (users don't directly create)
      allow write: if false;
    }

    match /regex_patterns/receipt_patterns/{patternId} {
      // All authenticated users can read patterns
      allow read: if isAuthenticated();

      // System creates patterns (users don't directly create)
      allow write: if false;
    }

    // Global Email Parsing Patterns (Smart Email Parsing)
    match /emailParsingPatterns/{patternId} {
      // All authenticated users can read global patterns
      allow read: if isAuthenticated();

      // Only Cloud Functions can create/update patterns (via admin SDK)
      // Users cannot directly write to global patterns
      allow write: if false;
    }
  }
}
