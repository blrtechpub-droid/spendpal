import 'local_transaction_model.dart';

/// Local regex pattern model for SMS/Email parsing
///
/// Privacy-First: All patterns stored locally in SQLite, never shared
///
/// These patterns are:
/// - Generated by AI after successful parsing
/// - Sender-specific (hashed for privacy)
/// - Used for fast parsing before AI fallback
/// - Higher priority than default patterns
class LocalPatternModel {
  final String id;
  final String senderHash; // SHA-256 hash of sender for privacy
  final TransactionSource source; // sms, email

  // Pattern details
  final String pattern; // Regex pattern
  final Map<String, dynamic> extractionMap; // Field mapping
  final String category; // Default category
  final bool isDebit; // true = expense, false = income

  // Optional
  final String? sampleText; // Sample SMS/email (for testing)
  final String? description; // User-friendly description

  // Statistics
  final double accuracy; // 0-100
  final int matchCount; // Successful matches
  final int failCount; // Failed matches
  final DateTime? lastMatchDate;

  // Metadata
  final DateTime createdAt;
  final DateTime updatedAt;
  final String userId;
  final bool isActive; // Can be disabled

  LocalPatternModel({
    required this.id,
    required this.senderHash,
    required this.source,
    required this.pattern,
    required this.extractionMap,
    required this.category,
    this.isDebit = true,
    this.sampleText,
    this.description,
    this.accuracy = 0.0,
    this.matchCount = 0,
    this.failCount = 0,
    this.lastMatchDate,
    DateTime? createdAt,
    DateTime? updatedAt,
    required this.userId,
    this.isActive = true,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  /// Create from SQLite Map
  factory LocalPatternModel.fromMap(Map<String, dynamic> map) {
    // Parse extraction map from JSON string
    final extractionMapJson = map['extraction_map'] as String?;
    final extractionMap = extractionMapJson != null
        ? _parseJson(extractionMapJson)
        : <String, dynamic>{};

    return LocalPatternModel(
      id: map['id'] as String,
      senderHash: map['sender_hash'] as String,
      source: TransactionSource.values.firstWhere(
        (e) => e.name == map['source'],
        orElse: () => TransactionSource.sms,
      ),
      pattern: map['pattern'] as String,
      extractionMap: extractionMap,
      category: map['category'] as String,
      isDebit: (map['is_debit'] as int) == 1,
      sampleText: map['sample_text'] as String?,
      description: map['description'] as String?,
      accuracy: (map['accuracy'] as num?)?.toDouble() ?? 0.0,
      matchCount: map['match_count'] as int? ?? 0,
      failCount: map['fail_count'] as int? ?? 0,
      lastMatchDate: map['last_match_date'] != null
          ? DateTime.parse(map['last_match_date'] as String)
          : null,
      createdAt: DateTime.parse(map['created_at'] as String),
      updatedAt: DateTime.parse(map['updated_at'] as String),
      userId: map['user_id'] as String,
      isActive: (map['is_active'] as int) == 1,
    );
  }

  /// Convert to SQLite Map
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'sender_hash': senderHash,
      'source': source.name,
      'pattern': pattern,
      'extraction_map': _toJsonString(extractionMap),
      'category': category,
      'is_debit': isDebit ? 1 : 0,
      'sample_text': sampleText,
      'description': description,
      'accuracy': accuracy,
      'match_count': matchCount,
      'fail_count': failCount,
      'last_match_date': lastMatchDate?.toIso8601String(),
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'user_id': userId,
      'is_active': isActive ? 1 : 0,
    };
  }

  /// Copy with method for updates
  LocalPatternModel copyWith({
    String? id,
    String? senderHash,
    TransactionSource? source,
    String? pattern,
    Map<String, dynamic>? extractionMap,
    String? category,
    bool? isDebit,
    String? sampleText,
    String? description,
    double? accuracy,
    int? matchCount,
    int? failCount,
    DateTime? lastMatchDate,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    bool? isActive,
  }) {
    return LocalPatternModel(
      id: id ?? this.id,
      senderHash: senderHash ?? this.senderHash,
      source: source ?? this.source,
      pattern: pattern ?? this.pattern,
      extractionMap: extractionMap ?? this.extractionMap,
      category: category ?? this.category,
      isDebit: isDebit ?? this.isDebit,
      sampleText: sampleText ?? this.sampleText,
      description: description ?? this.description,
      accuracy: accuracy ?? this.accuracy,
      matchCount: matchCount ?? this.matchCount,
      failCount: failCount ?? this.failCount,
      lastMatchDate: lastMatchDate ?? this.lastMatchDate,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? DateTime.now(), // Always update timestamp
      userId: userId ?? this.userId,
      isActive: isActive ?? this.isActive,
    );
  }

  /// Increment match count
  LocalPatternModel incrementMatch() {
    return copyWith(
      matchCount: matchCount + 1,
      lastMatchDate: DateTime.now(),
      accuracy: _calculateAccuracy(matchCount + 1, failCount),
    );
  }

  /// Increment fail count
  LocalPatternModel incrementFail() {
    return copyWith(
      failCount: failCount + 1,
      accuracy: _calculateAccuracy(matchCount, failCount + 1),
    );
  }

  /// Calculate accuracy percentage
  double _calculateAccuracy(int matches, int fails) {
    final total = matches + fails;
    if (total == 0) return 0.0;
    return (matches / total) * 100;
  }

  /// Helper to parse JSON string
  static Map<String, dynamic> _parseJson(String jsonString) {
    try {
      // Simple JSON parsing for extraction map
      // Format: {"amount": "group1", "merchant": "group2", ...}
      final map = <String, dynamic>{};
      final cleaned = jsonString.replaceAll('{', '').replaceAll('}', '').trim();
      if (cleaned.isEmpty) return map;

      final pairs = cleaned.split(',');
      for (final pair in pairs) {
        final parts = pair.split(':');
        if (parts.length == 2) {
          final key = parts[0].trim().replaceAll('"', '');
          final value = parts[1].trim().replaceAll('"', '');
          map[key] = value;
        }
      }
      return map;
    } catch (e) {
      print('Error parsing extraction map: $e');
      return {};
    }
  }

  /// Helper to convert map to JSON string
  static String _toJsonString(Map<String, dynamic> map) {
    if (map.isEmpty) return '{}';
    final entries = map.entries
        .map((e) => '"${e.key}":"${e.value}"')
        .join(',');
    return '{$entries}';
  }

  @override
  String toString() {
    return 'LocalPattern($senderHash, $category, $accuracy%, $matchCount matches)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is LocalPatternModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
