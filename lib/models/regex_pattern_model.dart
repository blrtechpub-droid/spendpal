import 'package:cloud_firestore/cloud_firestore.dart';

/// Model for self-learning regex patterns
/// These patterns are generated by AI and stored in Firebase
/// to enable fast, free parsing for similar future transactions
class RegexPatternModel {
  final String id;
  final String pattern;
  final String description;
  final String sender; // SMS sender (e.g., "HDFCBK")
  final String? bank; // Bank name (e.g., "HDFC Bank")
  final String type; // "debit", "credit", "credit_card", etc.
  final Map<String, int> extractionMap; // Field name → capture group number
  final String? categoryHint; // Suggested category

  // Performance metrics
  final int successCount;
  final int failCount;
  final double accuracy; // successCount / (successCount + failCount) * 100
  final int confidence; // AI's confidence in pattern (0-100)

  // Metadata
  final String createdBy; // "ai", "manual", "user"
  final DateTime createdAt;
  final DateTime lastUsed;
  final DateTime updatedAt;

  RegexPatternModel({
    required this.id,
    required this.pattern,
    required this.description,
    required this.sender,
    this.bank,
    required this.type,
    required this.extractionMap,
    this.categoryHint,
    required this.successCount,
    required this.failCount,
    required this.accuracy,
    required this.confidence,
    required this.createdBy,
    required this.createdAt,
    required this.lastUsed,
    required this.updatedAt,
  });

  /// Create from Firestore document
  factory RegexPatternModel.fromFirestore(String id, Map<String, dynamic> data) {
    return RegexPatternModel(
      id: id,
      pattern: data['pattern'] as String,
      description: data['description'] as String,
      sender: data['sender'] as String,
      bank: data['bank'] as String?,
      type: data['type'] as String,
      extractionMap: Map<String, int>.from(data['extractionMap'] as Map),
      categoryHint: data['categoryHint'] as String?,
      successCount: data['successCount'] as int? ?? 0,
      failCount: data['failCount'] as int? ?? 0,
      accuracy: (data['accuracy'] as num?)?.toDouble() ?? 100.0,
      confidence: data['confidence'] as int? ?? 100,
      createdBy: data['createdBy'] as String? ?? 'ai',
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastUsed: (data['lastUsed'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }

  /// Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'pattern': pattern,
      'description': description,
      'sender': sender,
      'bank': bank,
      'type': type,
      'extractionMap': extractionMap,
      'categoryHint': categoryHint,
      'successCount': successCount,
      'failCount': failCount,
      'accuracy': accuracy,
      'confidence': confidence,
      'createdBy': createdBy,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastUsed': Timestamp.fromDate(lastUsed),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Calculate cost saved by this pattern
  double get costSaved {
    // Each successful regex parse saves ₹0.13 (AI cost)
    return successCount * 0.13;
  }

  /// Check if pattern is performing well
  bool get isPerformingWell {
    final totalUses = successCount + failCount;
    if (totalUses < 5) return true; // Too early to judge
    return accuracy >= 85.0; // 85%+ accuracy
  }

  /// Get age of pattern
  Duration get age {
    return DateTime.now().difference(createdAt);
  }

  /// Copy with updated fields
  RegexPatternModel copyWith({
    String? pattern,
    String? description,
    String? sender,
    String? bank,
    String? type,
    Map<String, int>? extractionMap,
    String? categoryHint,
    int? successCount,
    int? failCount,
    double? accuracy,
    int? confidence,
    String? createdBy,
    DateTime? lastUsed,
    DateTime? updatedAt,
  }) {
    return RegexPatternModel(
      id: id,
      pattern: pattern ?? this.pattern,
      description: description ?? this.description,
      sender: sender ?? this.sender,
      bank: bank ?? this.bank,
      type: type ?? this.type,
      extractionMap: extractionMap ?? this.extractionMap,
      categoryHint: categoryHint ?? this.categoryHint,
      successCount: successCount ?? this.successCount,
      failCount: failCount ?? this.failCount,
      accuracy: accuracy ?? this.accuracy,
      confidence: confidence ?? this.confidence,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt,
      lastUsed: lastUsed ?? this.lastUsed,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

/// Model for AI-generated regex pattern
class GeneratedPattern {
  final String pattern;
  final String description;
  final Map<String, int> extractionMap;
  final int confidence; // 0-100
  final String? categoryHint;

  GeneratedPattern({
    required this.pattern,
    required this.description,
    required this.extractionMap,
    required this.confidence,
    this.categoryHint,
  });

  factory GeneratedPattern.fromJson(Map<String, dynamic> json) {
    return GeneratedPattern(
      pattern: json['pattern'] as String,
      description: json['description'] as String,
      extractionMap: Map<String, int>.from(json['extractionMap'] as Map),
      confidence: json['confidence'] as int,
      categoryHint: json['categoryHint'] as String?,
    );
  }
}

/// Result from regex parsing
class RegexParseResult {
  final String patternId;
  final Map<String, dynamic> extractedData;
  final RegexPatternModel pattern;

  RegexParseResult({
    required this.patternId,
    required this.extractedData,
    required this.pattern,
  });
}
