import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:spendpal/models/regex_pattern_model.dart';

/// Service for managing self-learning regex patterns
class RegexPatternService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  static final FirebaseAuth _auth = FirebaseAuth.instance;

  // Collection paths
  static const String _collectionPath = 'regex_patterns';
  static const String _smsDoc = 'sms_patterns';
  static const String _billDoc = 'bill_patterns';
  static const String _receiptDoc = 'receipt_patterns';

  /// Get all SMS regex patterns
  static Future<List<RegexPatternModel>> getSmsPatterns() async {
    try {
      final doc = await _firestore
          .collection(_collectionPath)
          .doc(_smsDoc)
          .get();

      if (!doc.exists || doc.data() == null) {
        return [];
      }

      final data = doc.data()!;
      return data.entries
          .map((e) => RegexPatternModel.fromFirestore(
                e.key,
                e.value as Map<String, dynamic>,
              ))
          .toList();
    } catch (e) {
      print('Error getting SMS patterns: $e');
      return [];
    }
  }

  /// Get SMS patterns for specific sender
  static Future<List<RegexPatternModel>> getPatternsForSender(String sender) async {
    final allPatterns = await getSmsPatterns();
    return allPatterns
        .where((p) => p.sender.toLowerCase() == sender.toLowerCase())
        .toList()
      ..sort((a, b) => b.accuracy.compareTo(a.accuracy)); // Best patterns first
  }

  /// Try to match SMS against all patterns for sender
  static Future<RegexParseResult?> tryMatchSms({
    required String smsText,
    required String sender,
  }) async {
    final patterns = await getPatternsForSender(sender);

    for (final pattern in patterns) {
      try {
        final regex = RegExp(pattern.pattern);
        final match = regex.firstMatch(smsText);

        if (match != null) {
          // Extract data using extraction map
          final extractedData = <String, dynamic>{};

          pattern.extractionMap.forEach((fieldName, groupNumber) {
            if (groupNumber <= match.groupCount) {
              extractedData[fieldName] = match.group(groupNumber);
            }
          });

          // Update pattern statistics (success)
          await _incrementPatternSuccess(pattern.id);

          print('‚úÖ Regex match found: ${pattern.id} (‚Çπ0 cost)');
          return RegexParseResult(
            patternId: pattern.id,
            extractedData: extractedData,
            pattern: pattern,
          );
        }
      } catch (e) {
        print('Error trying pattern ${pattern.id}: $e');
        continue; // Try next pattern
      }
    }

    return null; // No pattern matched
  }

  /// Save a new pattern generated by AI
  static Future<bool> savePattern({
    required GeneratedPattern generatedPattern,
    required String sender,
    required String type,
    String? bank,
  }) async {
    try {
      final patternId = _generatePatternId(sender);

      final pattern = RegexPatternModel(
        id: patternId,
        pattern: generatedPattern.pattern,
        description: generatedPattern.description,
        sender: sender,
        bank: bank,
        type: type,
        extractionMap: generatedPattern.extractionMap,
        categoryHint: generatedPattern.categoryHint,
        successCount: 0,
        failCount: 0,
        accuracy: 100.0,
        confidence: generatedPattern.confidence,
        createdBy: 'ai',
        createdAt: DateTime.now(),
        lastUsed: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _firestore
          .collection(_collectionPath)
          .doc(_smsDoc)
          .set({
            patternId: pattern.toFirestore(),
          }, SetOptions(merge: true));

      print('üéì New regex pattern saved: $patternId');
      print('   Sender: $sender | Confidence: ${generatedPattern.confidence}%');
      return true;
    } catch (e) {
      print('Error saving pattern: $e');
      return false;
    }
  }

  /// Increment pattern success count
  static Future<void> _incrementPatternSuccess(String patternId) async {
    try {
      final docRef = _firestore.collection(_collectionPath).doc(_smsDoc);
      final doc = await docRef.get();

      if (!doc.exists) return;

      final data = doc.data()!;
      final patternData = data[patternId] as Map<String, dynamic>?;

      if (patternData == null) return;

      final successCount = (patternData['successCount'] as int? ?? 0) + 1;
      final failCount = patternData['failCount'] as int? ?? 0;
      final accuracy = (successCount / (successCount + failCount)) * 100;

      await docRef.update({
        '$patternId.successCount': successCount,
        '$patternId.accuracy': accuracy,
        '$patternId.lastUsed': FieldValue.serverTimestamp(),
        '$patternId.updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print('Error incrementing success: $e');
      // Don't throw - this is just metrics
    }
  }

  /// Increment pattern fail count
  static Future<void> incrementPatternFail(String patternId) async {
    try {
      final docRef = _firestore.collection(_collectionPath).doc(_smsDoc);
      final doc = await docRef.get();

      if (!doc.exists) return;

      final data = doc.data()!;
      final patternData = data[patternId] as Map<String, dynamic>?;

      if (patternData == null) return;

      final successCount = patternData['successCount'] as int? ?? 0;
      final failCount = (patternData['failCount'] as int? ?? 0) + 1;
      final accuracy = (successCount / (successCount + failCount)) * 100;

      await docRef.update({
        '$patternId.failCount': failCount,
        '$patternId.accuracy': accuracy,
        '$patternId.updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print('Error incrementing fail: $e');
      // Don't throw - this is just metrics
    }
  }

  /// Get pattern statistics
  static Future<Map<String, dynamic>> getPatternStats() async {
    final patterns = await getSmsPatterns();

    if (patterns.isEmpty) {
      return {
        'totalPatterns': 0,
        'totalSuccesses': 0,
        'totalFails': 0,
        'avgAccuracy': 0.0,
        'costSaved': 0.0,
      };
    }

    final totalSuccesses = patterns.fold<int>(
      0,
      (sum, p) => sum + p.successCount,
    );

    final totalFails = patterns.fold<int>(
      0,
      (sum, p) => sum + p.failCount,
    );

    final avgAccuracy = patterns.fold<double>(
          0.0,
          (sum, p) => sum + p.accuracy,
        ) /
        patterns.length;

    final costSaved = patterns.fold<double>(
      0.0,
      (sum, p) => sum + p.costSaved,
    );

    return {
      'totalPatterns': patterns.length,
      'totalSuccesses': totalSuccesses,
      'totalFails': totalFails,
      'avgAccuracy': avgAccuracy,
      'costSaved': costSaved,
      'patterns': patterns
        ..sort((a, b) => b.successCount.compareTo(a.successCount)),
    };
  }

  /// Delete pattern
  static Future<bool> deletePattern(String patternId) async {
    try {
      await _firestore.collection(_collectionPath).doc(_smsDoc).update({
        patternId: FieldValue.delete(),
      });

      print('üóëÔ∏è Pattern deleted: $patternId');
      return true;
    } catch (e) {
      print('Error deleting pattern: $e');
      return false;
    }
  }

  /// Generate unique pattern ID
  static String _generatePatternId(String sender) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    return '${sender.toLowerCase()}_${timestamp}';
  }

  /// Stream of pattern statistics (for real-time UI)
  static Stream<Map<String, dynamic>> watchPatternStats() {
    return _firestore
        .collection(_collectionPath)
        .doc(_smsDoc)
        .snapshots()
        .asyncMap((_) async => await getPatternStats());
  }

  /// Check if pattern with similar regex already exists
  static Future<bool> patternExists(String pattern) async {
    final patterns = await getSmsPatterns();
    return patterns.any((p) => p.pattern == pattern);
  }

  // ============================================================================
  // BILL PATTERN METHODS
  // ============================================================================

  /// Get all bill regex patterns
  static Future<List<RegexPatternModel>> getBillPatterns() async {
    try {
      final doc = await _firestore
          .collection(_collectionPath)
          .doc(_billDoc)
          .get();

      if (!doc.exists || doc.data() == null) {
        return [];
      }

      final data = doc.data()!;
      return data.entries
          .map((e) => RegexPatternModel.fromFirestore(
                e.key,
                e.value as Map<String, dynamic>,
              ))
          .toList();
    } catch (e) {
      print('Error getting bill patterns: $e');
      return [];
    }
  }

  /// Get bill patterns for specific bank
  static Future<List<RegexPatternModel>> getPatternsForBank(String bank) async {
    final allPatterns = await getBillPatterns();
    return allPatterns
        .where((p) => p.bank?.toLowerCase() == bank.toLowerCase())
        .toList()
      ..sort((a, b) => b.accuracy.compareTo(a.accuracy));
  }

  /// Try to match bill text against patterns for bank
  static Future<RegexParseResult?> tryMatchBill({
    required String billText,
    required String bank,
  }) async {
    final patterns = await getPatternsForBank(bank);

    for (final pattern in patterns) {
      try {
        final regex = RegExp(pattern.pattern, multiLine: true);
        final match = regex.firstMatch(billText);

        if (match != null) {
          final extractedData = <String, dynamic>{};

          pattern.extractionMap.forEach((fieldName, groupNumber) {
            if (groupNumber <= match.groupCount) {
              extractedData[fieldName] = match.group(groupNumber);
            }
          });

          await _incrementBillPatternSuccess(pattern.id);

          print('‚úÖ Bill regex match found: ${pattern.id} (‚Çπ0 cost)');
          return RegexParseResult(
            patternId: pattern.id,
            extractedData: extractedData,
            pattern: pattern,
          );
        }
      } catch (e) {
        print('Error trying bill pattern ${pattern.id}: $e');
        continue;
      }
    }

    return null;
  }

  /// Save bill pattern
  static Future<bool> saveBillPattern({
    required GeneratedPattern generatedPattern,
    required String bank,
    required String type,
  }) async {
    try {
      final patternId = _generatePatternId(bank);

      final pattern = RegexPatternModel(
        id: patternId,
        pattern: generatedPattern.pattern,
        description: generatedPattern.description,
        sender: bank,
        bank: bank,
        type: type,
        extractionMap: generatedPattern.extractionMap,
        categoryHint: generatedPattern.categoryHint,
        successCount: 0,
        failCount: 0,
        accuracy: 100.0,
        confidence: generatedPattern.confidence,
        createdBy: 'ai',
        createdAt: DateTime.now(),
        lastUsed: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _firestore
          .collection(_collectionPath)
          .doc(_billDoc)
          .set({
            patternId: pattern.toFirestore(),
          }, SetOptions(merge: true));

      print('üéì New bill regex pattern saved: $patternId');
      print('   Bank: $bank | Confidence: ${generatedPattern.confidence}%');
      return true;
    } catch (e) {
      print('Error saving bill pattern: $e');
      return false;
    }
  }

  /// Increment bill pattern success count
  static Future<void> _incrementBillPatternSuccess(String patternId) async {
    try {
      final docRef = _firestore.collection(_collectionPath).doc(_billDoc);
      final doc = await docRef.get();

      if (!doc.exists) return;

      final data = doc.data()!;
      final patternData = data[patternId] as Map<String, dynamic>?;

      if (patternData == null) return;

      final successCount = (patternData['successCount'] as int? ?? 0) + 1;
      final failCount = patternData['failCount'] as int? ?? 0;
      final accuracy = (successCount / (successCount + failCount)) * 100;

      await docRef.update({
        '$patternId.successCount': successCount,
        '$patternId.accuracy': accuracy,
        '$patternId.lastUsed': FieldValue.serverTimestamp(),
        '$patternId.updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print('Error incrementing bill pattern success: $e');
    }
  }

  // ============================================================================
  // RECEIPT PATTERN METHODS
  // ============================================================================

  /// Get all receipt regex patterns
  static Future<List<RegexPatternModel>> getReceiptPatterns() async {
    try {
      final doc = await _firestore
          .collection(_collectionPath)
          .doc(_receiptDoc)
          .get();

      if (!doc.exists || doc.data() == null) {
        return [];
      }

      final data = doc.data()!;
      return data.entries
          .map((e) => RegexPatternModel.fromFirestore(
                e.key,
                e.value as Map<String, dynamic>,
              ))
          .toList();
    } catch (e) {
      print('Error getting receipt patterns: $e');
      return [];
    }
  }

  /// Get receipt patterns for specific merchant/store
  static Future<List<RegexPatternModel>> getPatternsForMerchant(String merchant) async {
    final allPatterns = await getReceiptPatterns();
    return allPatterns
        .where((p) => p.sender.toLowerCase() == merchant.toLowerCase())
        .toList()
      ..sort((a, b) => b.accuracy.compareTo(a.accuracy));
  }

  /// Try to match receipt text against patterns
  static Future<RegexParseResult?> tryMatchReceipt({
    required String receiptText,
    required String merchant,
  }) async {
    final patterns = await getPatternsForMerchant(merchant);

    for (final pattern in patterns) {
      try {
        final regex = RegExp(pattern.pattern, multiLine: true);
        final match = regex.firstMatch(receiptText);

        if (match != null) {
          final extractedData = <String, dynamic>{};

          pattern.extractionMap.forEach((fieldName, groupNumber) {
            if (groupNumber <= match.groupCount) {
              extractedData[fieldName] = match.group(groupNumber);
            }
          });

          await _incrementReceiptPatternSuccess(pattern.id);

          print('‚úÖ Receipt regex match found: ${pattern.id} (‚Çπ0 cost)');
          return RegexParseResult(
            patternId: pattern.id,
            extractedData: extractedData,
            pattern: pattern,
          );
        }
      } catch (e) {
        print('Error trying receipt pattern ${pattern.id}: $e');
        continue;
      }
    }

    return null;
  }

  /// Save receipt pattern
  static Future<bool> saveReceiptPattern({
    required GeneratedPattern generatedPattern,
    required String merchant,
    required String type,
  }) async {
    try {
      final patternId = _generatePatternId(merchant);

      final pattern = RegexPatternModel(
        id: patternId,
        pattern: generatedPattern.pattern,
        description: generatedPattern.description,
        sender: merchant,
        bank: null,
        type: type,
        extractionMap: generatedPattern.extractionMap,
        categoryHint: generatedPattern.categoryHint,
        successCount: 0,
        failCount: 0,
        accuracy: 100.0,
        confidence: generatedPattern.confidence,
        createdBy: 'ai',
        createdAt: DateTime.now(),
        lastUsed: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _firestore
          .collection(_collectionPath)
          .doc(_receiptDoc)
          .set({
            patternId: pattern.toFirestore(),
          }, SetOptions(merge: true));

      print('üéì New receipt regex pattern saved: $patternId');
      print('   Merchant: $merchant | Confidence: ${generatedPattern.confidence}%');
      return true;
    } catch (e) {
      print('Error saving receipt pattern: $e');
      return false;
    }
  }

  /// Increment receipt pattern success count
  static Future<void> _incrementReceiptPatternSuccess(String patternId) async {
    try {
      final docRef = _firestore.collection(_collectionPath).doc(_receiptDoc);
      final doc = await docRef.get();

      if (!doc.exists) return;

      final data = doc.data()!;
      final patternData = data[patternId] as Map<String, dynamic>?;

      if (patternData == null) return;

      final successCount = (patternData['successCount'] as int? ?? 0) + 1;
      final failCount = patternData['failCount'] as int? ?? 0;
      final accuracy = (successCount / (successCount + failCount)) * 100;

      await docRef.update({
        '$patternId.successCount': successCount,
        '$patternId.accuracy': accuracy,
        '$patternId.lastUsed': FieldValue.serverTimestamp(),
        '$patternId.updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print('Error incrementing receipt pattern success: $e');
    }
  }
}
